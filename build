#!/bin/bash

unset CDPATH
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

set -e

unset cleanup_kernels
unset cleanup_mountpoint
unset cleanup_partition1
unset cleanup_lodev
unset cleanup_bad_ova
unset cleanup_sparse_img
unset cleanup_dest_img
unset cleanup_ovf
unset cleanup_original_image
unset cleanup_created_image
unset cleanup_mf
cleanup() {
    [ -n "$NOCLEANUP" -a "$1" != "force" ] && exit || true
    [ -z "$cleanup_kernels" ] || {
        sudo rm -rf "$cleanup_kernels"
        unset cleanup_kernels
    }
    [ -z "$cleanup_mountpoint" ] || {
        sudo umount "$cleanup_mountpoint"
        unset cleanup_mountpoint
    }
    [ -z "$cleanup_partition1" ] || {
        sudo rmdir "$cleanup_partition1"
        unset cleanup_partition1
    }
    [ -z "$cleanup_lodev" ] || {
        sudo losetup -d "$cleanup_lodev"
        unset cleanup_lodev
    }
    [ -z "$cleanup_bad_ova" ] || {
        sudo rm -f "$cleanup_bad_ova"
        unset cleanup_bad_ova
    }
    [ -z "$cleanup_dest_img" ] || {
        sudo rm -f "$cleanup_dest_img"
        unset cleanup_dest_img
    }
    [ -z "$cleanup_sparse_img" ] || {
        sudo rm -f "$cleanup_sparse_img"
        unset cleanup_sparse_img
    }
    [ -z "$cleanup_ovf" ] || {
        sudo rm -f "$cleanup_ovf"
        unset cleanup_ovf
    }
    [ -z "$cleanup_original_image" ] || {
        sudo rm -f "$cleanup_original_image"
        unset cleanup_original_image
    }
    [ -z "$cleanup_created_image" ] || {
        sudo rm -f "$cleanup_created_image"
        unset cleanup_created_image
    }
    [ -z "$cleanup_mf" ] || {
        sudo rm -f "$cleanup_mf"
        unset cleanup_mf
    }
}
trap cleanup EXIT

targetdir="$1"

[ -n "$targetdir" ] || {
    echo "usage: build <outputdir>" >&2
    exit 64
}

pushd "$targetdir" > /dev/null

#download
if [ ! -f ubuntu-13.10-server-cloudimg-amd64-disk1.raw ] ; then
    wget -c --progress=bar https://cloud-images.ubuntu.com/releases/13.10/release/ubuntu-13.10-server-cloudimg-amd64-disk1.img
fi

#conversion to raw
if [ ! -f ubuntu-13.10-server-cloudimg-amd64-disk1.raw ] ; then
    qemu-img convert -O raw ubuntu-13.10-server-cloudimg-amd64-disk1.img ubuntu-13.10-server-cloudimg-amd64-disk1.raw
fi

#growth of the file (64 GB)
size=$((64*1024*1024*1024))
lastsector=$(($size/512-1))
if [ `stat -c%s ubuntu-13.10-server-cloudimg-amd64-disk1.raw` != $size ] ; then
    python -c '
import sys
f = open(sys.argv[1], "ab")
maxsize = long(sys.argv[2])
f.truncate(maxsize)
f.close()
' ubuntu-13.10-server-cloudimg-amd64-disk1.raw $size
fi

#growth of the enclosing partition
if echo p | sudo fdisk ubuntu-13.10-server-cloudimg-amd64-disk1.raw | grep -q $lastsector ; then
    true
else
    echo '
d
n
p



w
' | sudo fdisk ubuntu-13.10-server-cloudimg-amd64-disk1.raw
fi

#mapping to loopback dev
lodev=`
losetup -l | python -c '
import sys
stuffs = dict([ (l[41:-1],l[0:10]) for l in sys.stdin.readlines()[1:] ])
if sys.argv[1] in stuffs:
    print stuffs[sys.argv[1]]
' "$PWD"/ubuntu-13.10-server-cloudimg-amd64-disk1.raw
`
if [ -z "$lodev" ] ; then
    lodev=`sudo losetup -P --find --show "$PWD"/ubuntu-13.10-server-cloudimg-amd64-disk1.raw`
fi
cleanup_lodev="$lodev"

#resize partitions
if ! mountpoint -q partition1 ; then
        # do NOT do this if the file system is mounted
        sudo e2fsck -f "$lodev"p1
        sudo resize2fs "$lodev"p1
fi

#mount partitions
mkdir -p partition1
cleanup_partition1="$PWD"/partition1
mountpoint -q partition1 || sudo mount "$lodev"p1 partition1
cleanup_mountpoint="$PWD"/partition1

popd > /dev/null

#setup networking in chroot
sudo rm -f "$cleanup_mountpoint"/etc/resolv.conf
sudo cp -f /etc/resolv.conf "$cleanup_mountpoint"/etc/resolv.conf

#fool system into believing that shit exists
fakedir="$cleanup_mountpoint"/fake
sudo mkdir -p "$fakedir"
for a in initctl invoke-rc.d restart start stop start-stop-daemon service ; do
    echo "#/bin/bash" | sudo tee "$fakedir"/$a > /dev/null
    sudo chmod +x "$fakedir"/$a
done

#fire ansible up
sudo ANSIBLE_NOCOWS=1 PATH=/fake:/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin ansible-playbook -c chroot -i "$cleanup_mountpoint", "$DIR"/setup.yml

#restore networking in chroot
sudo ln -sf ../run/resolvconf/etc/resolv.conf "$cleanup_mountpoint"/etc/resolv.conf

#cleanup the fake stuff
sudo rm -rf "$fakedir"

#get the kernel and initrd out
mkdir -p "$targetdir"/kernels
cleanup_kernels="$targetdir"/kernels
for a in "$cleanup_mountpoint"/boot/vmlinuz-* ; do
    kernel=`basename "$a"`
    cp -fR "$a" "$cleanup_kernels"
    break
done
for a in "$cleanup_mountpoint"/boot/initrd.img-* ; do
    initrd=`basename "$a"`
    cp -fR "$a" "$cleanup_kernels"
    break
done

#write creation of bootloader
cat > "$cleanup_mountpoint"/installbootloader << EOF
#!/bin/bash

mount / -o remount,rw
grub-install /dev/sda
update-grub
rm -f /installbootloader
sync
mount / -o remount,ro
sync
echo 1 > /proc/sys/kernel/sysrq
echo o > /proc/sysrq-trigger
sleep 5
echo cannot power off VM.  Please kill -15 this qemu process.
EOF
chmod +x "$cleanup_mountpoint"/installbootloader

#cleanup everything but the lodev
savedshit="$cleanup_lodev"
savedshit2="$cleanup_kernels"
unset cleanup_lodev
unset cleanup_kernels
cleanup force
cleanup_lodev="$savedshit"
cleanup_kernels="$savedshit2"
unset savedshit
unset savedshit2

#install bootloader
vmuuid=`python -c 'import uuid; print str(uuid.uuid1())'`
qemu-system-x86_64 -enable-kvm -name dts-publishingstudio -M pc-1.2 -no-reboot -m 512 -uuid "$vmuuid" -kernel "$cleanup_kernels"/"$kernel" -initrd "$cleanup_kernels"/"$initrd" -append "root=/dev/sda1 ro init=/installbootloader console=ttyS0" -drive file="$lodev",if=none,id=drive-ide0-0-0,format=raw -device ide-hd,bus=ide.0,unit=0,drive=drive-ide0-0-0,id=ide0-0-0,bootindex=1 -nographic -serial /dev/stdout

if [ -z "$NOZEROFREE" ] ; then
    #zerofree the partition image
    sudo zerofree -v "$lodev"p1
fi

#copy the OVF
cp -f "$DIR"/dts-publishingstudio-13.10-amd64.ovf "$targetdir"
cleanup_ovf="$targetdir"/dts-publishingstudio-13.10-amd64.ovf

pushd "$targetdir" > /dev/null

#create image
cleanup_sparse_img="$PWD"/dts-publishingstudio-13.10-amd64-disk1.sparsevmdk
qemu-img convert -S 512 -o subformat=monolithicSparse -O vmdk ubuntu-13.10-server-cloudimg-amd64-disk1.raw dts-publishingstudio-13.10-amd64-disk1.sparsevmdk
cleanup_dest_img="$PWD"/dts-publishingstudio-13.10-amd64-disk1.vmdk
# because the next command fails unless I do this
rm -f dts-publishingstudio-13.10-amd64-disk1.vmdk
# because of suggestion in https://github.com/ceph/inktank-training-vms/commit/52bc4084e39739e4778a694153b5f8309cdb0b82#diff-a53108f7543b75adbb34afc035d4cdf6R29
vboxmanage clonehd --format=VMDK --variant=Stream dts-publishingstudio-13.10-amd64-disk1.sparsevmdk dts-publishingstudio-13.10-amd64-disk1.vmdk
chmod 644 dts-publishingstudio-13.10-amd64-disk1.vmdk

ovfsum=`sha256sum dts-publishingstudio-13.10-amd64.ovf | cut -d ' ' -f 1`
imgsum=`sha256sum dts-publishingstudio-13.10-amd64-disk1.vmdk | cut -d ' ' -f 1`

#generate manifest for extra anti-tampering goodness
cleanup_mf="$PWD"/dts-publishingstudio-13.10-amd64.mf
cat > dts-publishingstudio-13.10-amd64.mf << EOF
SHA256 (dts-publishingstudio-13.10-amd64.ovf)= $ovfsum
SHA256 (dts-publishingstudio-13.10-amd64-disk1.vmdk)= $imgsum
EOF

#tar it all up
cleanup_bad_ova="$PWD"/dts-publishingstudio-13.10-amd64.ova.xz
tar cv dts-publishingstudio-13.10-amd64.ovf dts-publishingstudio-13.10-amd64-disk1.vmdk dts-publishingstudio-13.10-amd64.mf | pxz -cv - > dts-publishingstudio-13.10-amd64.ova.xz
cleanup_bad_ova=

cleanup_original_image="$targetdir"/ubuntu-13.10-server-cloudimg-amd64-disk1.vmdk
cleanup_created_image="$targetdir"/ubuntu-13.10-server-cloudimg-amd64-disk1.raw

popd > /dev/null
